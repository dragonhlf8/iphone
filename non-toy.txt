import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.library import QFT
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt

# --- secp256k1 curve parameters (Bitcoin curve) ---
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
a = 0
b = 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141  # order of G

# Given compressed public key (hex string)
public_key_hex = "033f688bae8321b8e02b7e6c0a55c2515fb25ab97d85fda842449f7bfa04e128c3"

# Private key search range (17-bit range)
min_range = 0x10000
max_range = 0x1FFFFF
keyspace_size = max_range - min_range + 1

# Number of counting qubits for QPE (ceil(log2(keyspace_size)) + 1 for safety)
num_qubits = int(np.ceil(np.log2(keyspace_size))) + 1

# --- Elliptic curve arithmetic functions (classical) ---

def mod_inverse(k, p):
    """Modular inverse using Extended Euclidean Algorithm."""
    if k == 0:
        raise ZeroDivisionError('division by zero')
    return pow(k, p - 2, p)

def point_addition(P, Q):
    """Add two points P and Q on the elliptic curve."""
    if P is None:
        return Q
    if Q is None:
        return P
    (x1, y1) = P
    (x2, y2) = Q
    if x1 == x2 and (y1 + y2) % p == 0:
        return None  # Point at infinity
    if P == Q:
        # Point doubling
        m = (3 * x1 * x1 + a) * mod_inverse(2 * y1, p) % p
    else:
        m = (y2 - y1) * mod_inverse(x2 - x1, p) % p
    x3 = (m * m - x1 - x2) % p
    y3 = (m * (x1 - x3) - y1) % p
    return (x3, y3)

def scalar_multiplication(k, P):
    """Multiply point P by scalar k on the elliptic curve."""
    R = None
    Q = P
    while k > 0:
        if k & 1:
            R = point_addition(R, Q)
        Q = point_addition(Q, Q)
        k >>= 1
    return R

def decompress_public_key(pubkey_hex):
    """Decompress compressed public key to (x,y) point."""
    prefix = pubkey_hex[:2]
    x = int(pubkey_hex[2:], 16)
    alpha = (pow(x, 3, p) + b) % p
    beta = pow(alpha, (p + 1) // 4, p)  # sqrt mod p since p % 4 == 3
    if (beta % 2 == 0 and prefix == '02') or (beta % 2 == 1 and prefix == '03'):
        y = beta
    else:
        y = p - beta
    return (x, y)

# Decompress given public key
public_key_point = decompress_public_key(public_key_hex)

# --- Quantum Phase Estimation Oracle ---

-------------------------

1. Simplified Oracle (Phase Rotation)
What it does:
Encodes the secret private key as a phase angle 
\theta = \frac{\text{private_key}}{N}
 and applies controlled phase rotations on a target qubit.
Why simplified:
It does not perform any elliptic curve point multiplication or group operations on quantum registers.
Use case:
Educational/demo QPE to estimate a phase proportional to the private key.
python


def apply_controlled_unitary(qc, control_qubit, target_qubit, power, private_key, keyspace_size):
    """
    Apply controlled phase rotation U^{2^power} for QPE.
    Angle = 2 * pi * private_key * 2^power / keyspace_size
    """
    angle = 2 * np.pi * private_key * (2 ** power) / keyspace_size
    qc.cu1(angle, control_qubit, target_qubit)
In the QPE circuit, this function is called repeatedly with increasing powers to build the phase estimation.
------------------------------------------------

# For demonstration, encode the private key as a phase theta = private_key / keyspace_size
# In reality, the oracle would perform elliptic curve multiplication and compare to public key (very complex)

# Example secret private key in range (unknown to attacker)
secret_private_key = 0x123456  # Change as needed within min_range..max_range

def apply_controlled_unitary(qc, control_qubit, target_qubit, power):
    """Apply controlled phase rotation U^{2^power} for QPE."""
    angle = 2 * np.pi * secret_private_key * (2 ** power) / keyspace_size
    qc.cu1(angle, control_qubit, target_qubit)

def quantum_phase_estimation(num_qubits):
    """Build QPE circuit to estimate phase = secret_private_key / keyspace_size."""
    qc = QuantumCircuit(num_qubits + 1, num_qubits)

    # Apply Hadamard gates to counting register
    for q in range(num_qubits):
        qc.h(q)

    # Prepare eigenstate |1> on target qubit
    qc.x(num_qubits)

    # Apply controlled unitary operations
    for q in range(num_qubits):
        apply_controlled_unitary(qc, q, num_qubits, num_qubits - q - 1)

    # Apply inverse QFT on counting register
    qc.append(QFT(num_qubits, inverse=True, do_swaps=True), range(num_qubits))

    # Measure counting register
    qc.measure(range(num_qubits), range(num_qubits))

    return qc

def run_circuit_on_ibm(qc, backend_name="ibm_brisbane", shots=1024):
    # Save your IBM Quantum account token here
    QiskitRuntimeService.save_account(
        channel='ibm_quantum',
        token='YOUR_IBM_QUANTUM_TOKEN_HERE',  # Replace with your token
        instance='ibm-q/open/main',
        overwrite=True,
        set_as_default=True
    )
    service = QiskitRuntimeService()
    backend = service.backend(backend_name)

    print(f"Running on backend: {backend.name}")

    transpiled_qc = transpile(qc, backend=backend, optimization_level=3)
    sampler = Sampler(backend=backend)

    job = sampler.run([transpiled_qc], shots=shots)
    print(f"Job submitted with ID: {job.job_id()}")

    result = job.result()
    counts = result[0].data.c.get_counts()
    return counts

def main():
    print(f"Private key search range: {hex(min_range)} to {hex(max_range)}")
    print(f"Number of counting qubits: {num_qubits}")
    print(f"Secret private key (unknown to attacker): {hex(secret_private_key)}")
    print(f"Given public key point (x,y):\n{public_key_point}")

    qc = quantum_phase_estimation(num_qubits)
    print("Quantum circuit:")
    print(qc.draw(fold=-1))

    counts = run_circuit_on_ibm(qc, shots=2048)
    print("Measurement results:")
    print(counts)

    plot_histogram(counts)
    plt.show()

    # Post-processing: find the most frequent measurement and estimate phase
    max_key = max(counts, key=counts.get)
    measured_int = int(max_key, 2)
    estimated_phase = measured_int / (2 ** num_qubits)
    estimated_private_key = round(estimated_phase * keyspace_size) + min_range

    print(f"Estimated phase: {estimated_phase}")
    print(f"Estimated private key (approx): {hex(estimated_private_key)}")
    print(f"Actual private key: {hex(secret_private_key)}")

if __name__ == "__main__":
    main()
