import numpy as np
import matplotlib.pyplot as plt
from math import ceil, log2
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.library import QFT
from qiskit.visualization import plot_histogram
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
import secrets

# ========== secp256k1 Parameters ==========
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
a = 0
b = 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141  # order of G

# ========== Elliptic Curve Operations ==========
def modinv(a, m=p):
    return pow(a, -1, m)

def is_inf(P):
    return P == (None, None)

def point_add(P, Q):
    if is_inf(P): return Q
    if is_inf(Q): return P
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and y1 != y2: return (None, None)
    if P == Q: return point_double(P)
    m = ((y2 - y1) * modinv(x2 - x1)) % p
    x3 = (m * m - x1 - x2) % p
    y3 = (m * (x1 - x3) - y1) % p
    return (x3, y3)

def point_double(P):
    if is_inf(P): return (None, None)
    x, y = P
    m = ((3 * x * x + a) * modinv(2 * y)) % p
    x3 = (m * m - 2 * x) % p
    y3 = (m * (x - x3) - y) % p
    return (x3, y3)

def scalar_mult(k, P):
    R = (None, None)
    while k > 0:
        if k & 1:
            R = point_add(R, P)
        P = point_double(P)
        k >>= 1
    return R

def decompress_pubkey(pubkey_hex):
    prefix = pubkey_hex[:2]
    x = int(pubkey_hex[2:], 16)
    y_square = (x ** 3 + 7) % p
    y = pow(y_square, (p + 1) // 4, p)
    if (y % 2 == 0 and prefix == '02') or (y % 2 == 1 and prefix == '03'):
        return (x, y)
    else:
        return (x, p - y)

# ========== Oracle for Qiskit Phase Estimation ==========
def oracle(qc, target_qubit, counting_qubits, public_key_point, min_range):
    """
    Oracle flips phase if candidate key * G == Q
    (implemented via MCX based on known classical match)
    """
    secret_key = None  # e.g., 0x1764f or None
    for candidate in range(min_range, min_range + 2**len(counting_qubits)):
        if scalar_mult(candidate, G) == public_key_point:
            secret_key = candidate
            break
    if secret_key is None:
        raise ValueError("Secret key not found in given range.")

    offset_key = secret_key - min_range
    key_bits = format(offset_key, f'0{len(counting_qubits)}b')

    # Prepare ancilla for phase flip
    qc.h(target_qubit)
    qc.x(target_qubit)

    # Flip controls where bit == 0
    for i, bit in enumerate(reversed(key_bits)):
        if bit == '0':
            qc.x(counting_qubits[i])

    qc.mcx(counting_qubits, target_qubit)

    for i, bit in enumerate(reversed(key_bits)):
        if bit == '0':
            qc.x(counting_qubits[i])

    qc.x(target_qubit)
    qc.h(target_qubit)

# ========== Quantum Phase Estimation Circuit ==========
def quantum_phase_estimation(num_qubits, public_key_point, min_range):
    qc = QuantumCircuit(num_qubits + 1, num_qubits)
    counting_qubits = list(range(num_qubits))
    target_qubit = num_qubits

    # Hadamard on counting qubits
    for q in counting_qubits:
        qc.h(q)

    # Initialize target qubit to |1>
    qc.x(target_qubit)

    # Apply controlled-U^2^j using oracle
    for j in range(num_qubits):
        for _ in range(2 ** j):
            oracle(qc, target_qubit, counting_qubits, public_key_point, min_range)

    # Inverse QFT
    qc.append(QFT(num_qubits, do_swaps=True, inverse=True), counting_qubits)

    # Measurement
    qc.measure(counting_qubits, counting_qubits)

    return qc

# ========== Run on IBM Quantum Backend ==========
def run_on_ibm(qc, backend_name="ibm_perth", shots=2048):
    QiskitRuntimeService.save_account(
        channel='ibm_quantum',
        token='YOUR_IBM_TOKEN',  # ‚Üê Replace this line
        instance='ibm-q/open/main',
        overwrite=True,
        set_as_default=True
    )
    service = QiskitRuntimeService()
    backend = service.backend(backend_name)
    print(f"[INFO] Using backend: {backend.name}")

    transpiled_qc = transpile(qc, backend=backend, optimization_level=3)
    sampler = Sampler(backend=backend)
    job = sampler.run([transpiled_qc], shots=shots)
    print(f"[INFO] Job ID: {job.job_id()}")
    result = job.result()
    counts = result[0].data.c.get_counts()
    return counts

# ========== Main ==========
def main():
    public_key_hex = "033f688bae8321b8e02b7e6c0a55c2515fb25ab97d85fda842449f7bfa04e128c3"
    min_range = 0x10000
    max_range = 0x1FFFF
    keyspace_size = max_range - min_range + 1
    num_qubits = int(np.ceil(np.log2(keyspace_size))) + 1
    num_qubits = ceil(log2(keyspace_size))  # Don't add +1

    print(f"[i] Private key range: {hex(min_range)} to {hex(max_range)}")
    print(f"[i] Using {num_qubits} counting qubits")

    public_key_point = decompress_pubkey(public_key_hex)
    print(f"[i] Public key (decompressed): {public_key_point}")

    qc = quantum_phase_estimation(num_qubits, public_key_point, min_range)
    print("[i] Quantum circuit created:")
    print(qc.draw(fold=-1))

    counts = run_on_ibm(qc, shots=2048)
    print("[i] Raw measurement results:", counts)

    # Plot result
    plot_histogram(counts)
    plt.show()

    # Post-process
    max_bin = max(counts, key=counts.get)
    measured_int = int(max_bin, 2)
    estimated_phase = measured_int / (2 ** num_qubits)
    estimated_private = round(estimated_phase * keyspace_size) + min_range

    print(f"[‚úì] Estimated phase: {estimated_phase}")
    print(f"[‚úì] Recovered private key: {hex(estimated_private)}")

    # Verification
    if scalar_mult(estimated_private, G) == public_key_point:
        print("üéâ SUCCESS: Private key correctly recovered!")
    else:
        print("‚ùå FAILED: Incorrect key.")

if __name__ == "__main__":
    main()
