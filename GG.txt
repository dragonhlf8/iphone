import numpy as np
import matplotlib.pyplot as plt
from math import ceil, log2, gcd
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.library import QFT
from qiskit.visualization import plot_histogram
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
import secrets

# ========== secp256k1 Parameters ==========
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
a = 0
b = 7
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
G = (Gx, Gy)
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141  # Order of G

# ========== Elliptic Curve Operations ==========
def modinv(a, m=p):
    return pow(a, -1, m)

def is_inf(P):
    return P == (None, None)

def point_add(P, Q):
    if is_inf(P): return Q
    if is_inf(Q): return P
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and y1 != y2: return (None, None)
    if P == Q: return point_double(P)
    m = ((y2 - y1) * modinv(x2 - x1)) % p
    x3 = (m * m - x1 - x2) % p
    y3 = (m * (x1 - x3) - y1) % p
    return (x3, y3)

def point_double(P):
    if is_inf(P): return (None, None)
    x, y = P
    m = ((3 * x * x + a) * modinv(2 * y)) % p
    x3 = (m * m - 2 * x) % p
    y3 = (m * (x - x3) - y) % p
    return (x3, y3)

def scalar_mult(k, P):
    R = (None, None)
    while k > 0:
        if k & 1:
            R = point_add(R, P)
        P = point_double(P)
        k >>= 1
    return R

def decompress_pubkey(pubkey_hex):
    prefix = pubkey_hex[:2]
    x = int(pubkey_hex[2:], 16)
    y_square = (x ** 3 + 7) % p
    y = pow(y_square, (p + 1) // 4, p)
    if (y % 2 == 0 and prefix == '02') or (y % 2 == 1 and prefix == '03'):
        return (x, y)
    else:
        return (x, p - y)

def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    g, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return g, x, y

# ========== Oracle ==========
# New oracle creation function
def create_oracle_with_ancilla(num_qubits, target_state):
    """Creates an oracle circuit that marks the target state using an ancillary qubit."""
    oracle_circuit = QuantumCircuit(num_qubits + 1)  # +1 for ancilla

    # Initialize ancilla to |1⟩
    oracle_circuit.x(num_qubits)

    # Apply X gates to flip 0s in the target state
    for i, bit in enumerate(bin(target_state)[2:].zfill(num_qubits)):
        if bit == '0':
            oracle_circuit.x(i)

    # Apply multi-controlled Z using ancilla as control and last qubit as target
    oracle_circuit.cz(num_qubits, num_qubits - 1)

    # Undo the X gates
    for i, bit in enumerate(bin(target_state)[2:].zfill(num_qubits)):
        if bit == '0':
            oracle_circuit.x(i)

    # Reset ancilla
    oracle_circuit.x(num_qubits)

    return oracle_circuit


def oracle(qc, target_qubit, counting_qubits, public_key_point, min_range):
    secret_key = None  # e.g., 0x1764f or None
    for candidate in range(min_range, min_range + 2**len(counting_qubits)):
        if scalar_mult(candidate, G) == public_key_point:
            secret_key = candidate
            break
    if secret_key is None:
        raise ValueError("Secret key not found in given range.")

    offset_key = secret_key - min_range
    key_bits = format(offset_key, f'0{len(counting_qubits)}b')
    # qc.z(target_qubit)
    # Apply phase oracle
    qc.h(target_qubit)
    qc.x(target_qubit)
    for i, bit in enumerate(reversed(key_bits)):
        if bit == '0':
            qc.x(counting_qubits[i])
    qc.mcx(counting_qubits, target_qubit)
    for i, bit in enumerate(reversed(key_bits)):
        if bit == '0':
            qc.x(counting_qubits[i])
    qc.x(target_qubit)
    qc.h(target_qubit)

# ========== Quantum Phase Estimation ==========
def quantum_phase_estimation(num_qubits, target_state):
    qc = QuantumCircuit(num_qubits + 1, num_qubits)
    counting_qubits = list(range(num_qubits))
    ancilla_qubit = num_qubits

    # Apply Hadamard to counting qubits
    for q in counting_qubits:
        qc.h(q)

    # Apply X to ancilla to initialize to |1⟩
    qc.x(ancilla_qubit)

    # Apply controlled-U^2^j using oracles
    for j in range(num_qubits):
        repetitions = 2 ** j
        oracle = create_oracle_with_ancilla(num_qubits, target_state)
        for _ in range(repetitions):
            qc.compose(oracle, qubits=range(num_qubits + 1), inplace=True)

    # Apply inverse QFT
    qc.append(QFT(num_qubits, do_swaps=True, inverse=True), counting_qubits)

    # Measure
    qc.measure(counting_qubits, counting_qubits)
    return qc

def quantum_phase_estimation(num_qubits, public_key_point, min_range):
    qc = QuantumCircuit(num_qubits + 1, num_qubits)
    counting_qubits = list(range(num_qubits))
    target_qubit = num_qubits

    for q in counting_qubits:
        qc.h(q)
    qc.x(target_qubit)

    for j in range(num_qubits):
        for _ in range(2 ** j):
            oracle(qc, target_qubit, counting_qubits, public_key_point, min_range)

    qc.append(QFT(num_qubits, do_swaps=True, inverse=True), counting_qubits)
    qc.measure(counting_qubits, counting_qubits)
    return qc

# ========== Run on IBM Quantum ==========
def run_on_ibm(qc, backend_name="ibm_perth", shots=8192):
    QiskitRuntimeService.save_account(
        channel='ibm_quantum',
        token='YOUR_IBM_TOKEN',  # Replace this
        instance='ibm-q/open/main',
        overwrite=True,
        set_as_default=True
    )
    service = QiskitRuntimeService()
    backend = service.backend(backend_name)
    print(f"[INFO] Using backend: {backend.name}")
    transpiled_qc = transpile(qc, backend=backend, optimization_level=3)
    sampler = Sampler(backend=backend)
    job = sampler.run([transpiled_qc], shots=shots)
    print(f"[INFO] Job ID: {job.job_id()}")
    result = job.result()
    counts = result[0].data.c.get_counts()
    return counts

# ========== Main ==========
def main():
    public_key_hex = "033f688bae8321b8e02b7e6c0a55c2515fb25ab97d85fda842449f7bfa04e128c3"
    min_range = 0x10000
    max_range = 0x1FFFF
    keyspace_size = max_range - min_range + 1
    num_qubits = ceil(log2(keyspace_size))  # Don't add +1
    num_qubits = int(np.ceil(np.log2(keyspace_size))) + 1

    print(f"[i] Private key range: {hex(min_range)} to {hex(max_range)}")
    print(f"[i] Counting qubits: {num_qubits}")

    public_key_point = decompress_pubkey(public_key_hex)
    print(f"[i] Decompressed public key: {public_key_point}")

    # === Compute the secret key in the defined range ===
    secret_key = None
    for candidate in range(min_range, min_range + 2**num_qubits):
        if scalar_mult(candidate, G) == public_key_point:
            secret_key = candidate
            break
    if secret_key is None:
        raise ValueError("Secret key not found in given range.")

    # Offset key into the range
    target_state = secret_key - min_range
    print(f"[✓] Secret key found: {hex(secret_key)} | target_state: {target_state}")

    # Build QPE circuit using clean oracle
    qc = quantum_phase_estimation(num_qubits, target_state)
    print("[i] Quantum circuit with oracle created:")
    print(qc.draw(fold=-1))

    counts = run_on_ibm(qc, shots=8192)
    print("[i] Measurement results:", counts)
    plot_histogram(counts)
    plt.show()

    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)
    found = False

    for bitstring, freq in sorted_counts:
        measured_int = int(bitstring, 2)
        if gcd(measured_int, 2 ** num_qubits) != 1:
            continue  # Skip if not coprime

        estimated_phase = measured_int / (2 ** num_qubits)
        estimated_key = round(estimated_phase * keyspace_size) + min_range

        print(f"[?] Trying key: {hex(estimated_key)} from phase {estimated_phase:.6f}")

        if scalar_mult(estimated_key, G) == public_key_point:
            print(f"[✓] SUCCESS! Private key found: {hex(estimated_key)}")
            found = True
            break

    if not found:
        print("❌ No valid private key found with GCD filtering.")

if __name__ == "__main__":
    main()
