Truly Deadly Arson furnite
Normal difficulty Sigma sector, 
Broken Boundary / Isolated Desert areas

well any real progress has done via ibm quantum machine to use alternative method of Shor's Algorithm to break ECDSA of BTC using Publickey if yes and they successed cracking unlocking low puzzle btc or mini privatekey so show me the full quantum algorithme used there 
simmilaire  litllebit to this one here : # Assembling the circuit into a Qobj.../content/01.py:400: DeprecationWarning: The function ``qiskit.compiler.assembler.assemble()`` is deprecated as of qiskit 1.2. It will be removed in the 2.0 release.
# The `Qobj` class and related functionality are part of the deprecated `BackendV1` workflow,  and no longer necessary for `BackendV2`. If a user workflow requires `Qobj` it likely relies on deprecated functionality and should be updated to use `BackendV2`. qobj = assemble(transpiled_circuit) Qobj assembled successfully.
#import qctrl
#import qctrlvisualizer as qv
#import fireopal as fo
#import boulderopal as bo
#from qctrl import QAQA, QPE, QEC
import numpy as np
from qiskit import transpile
from qiskit.visualization import plot_histogram, plot_distribution
from qiskit import QuantumCircuit, transpile
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options
from qiskit.circuit.library import QFT
from qiskit.circuit import QuantumRegister, ClassicalRegister
import numpy as np
from fractions import Fraction
from math import gcd
import logging
from collections import Counter
from qiskit.circuit.controlflow.break_loop import BreakLoopPlaceholder
from qiskit.circuit.library import ZGate, MCXGate
from collections import Counter
from Crypto.Hash import RIPEMD160, SHA256  # Import from pycryptodome
from ecdsa import SigningKey, SECP256k1
from qiskit.quantum_info import PauliList, SparsePauliOp, Statevector, Operator
from qiskit.circuit import Parameter
#from qiskit_aer.primitives import SamplerV2  # for simulator
#from qiskit_ibm_runtime import SamplerV2 as real_sampler  # for hardware
from qiskit.circuit.library import RYGate
#from qiskit.providers.ibmq.job import Job
from Crypto.PublicKey import ECC
from bitarray import bitarray
#from qiskit_aer.primitives import SamplerV2  # for simulator
#from qiskit_ibm_runtime import SamplerV2 as real_sampler  # for hardware
#from qiskit_algorithms.optimizers import AmplificationProblem, CustomCircuitOracle
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_aer import AerSimulator, Aer
from qiskit_ibm_runtime import Estimator
from qiskit.circuit.library import RYGate, GroverOperator
from math import ceil, log2
#from qiskit.providers.ibmq import IBMQ
import matplotlib.pyplot as plt
from qiskit import QuantumRegister, ClassicalRegister, AncillaRegister
import numpy as np
import random
import time
import hashlib
import base58
import math
#from qctrlcommons.preconditions import check_argument_integer
# Setup Fire-Opal
#bo.cloud.set_organization("aimen-eldjoundi-gmail")
#bo.authenticate_qctrl_account("ZGmK5goCNAKxiOfFCMJZbShiX7jk8llgKGBVASGSerYNYE131L")
#bo.cloud.request_machines(1)
#fo.config.configure_organization(organization_slug="aimen-eldjoundi-gmail")
#fo.authenticate_qctrl_account("ZGmK5goCNAKxiOfFCMJZbShiX7jk8llgKGBVASGSerYNYE131L")

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load IBM Quantum account (replace with your token)
QiskitRuntimeService.save_account(
    channel='ibm_quantum',
    token='29e1878ddfb11fd8422a7c7c2f07521420b73988a7b1bd610b81758122de534d90abdb90466b747d81c43aea6c81147d89de8c551e24d4a30f584419e96e3659',  # Replace with your IBM Quantum token
    instance='ibm-q/open/main',
    overwrite=True,
    set_as_default=True
)

# Load the service
service = QiskitRuntimeService()
backend = service.backend("ibm_brisbane")

# Secp256k1 curve parameters

SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
g_x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
g_y = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
A = 0
B = 7
G_X = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798  # Standard G_X
G_Y = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8  # Standard G_Y

def mod_inverse(a, p):
    if a == 0:
        return 0
    lm, hm = 1, 0
    low, high = a % p, p
    while low > 1:
        ratio = high // low
        nm, new_low = hm - lm * ratio, high - low * ratio
        lm, low, hm, high = nm, new_low, lm, low
    return lm % p

def point_doubling(x, y, p):
    s = (3 * x**2) * pow(2 * y, -1, p) % p
    x_res = (s**2 - 2 * x) % p
    y_res = (s * (x - x_res) - y) % p
    return x_res, y_res

def point_addition(x1, y1, x2, y2, p=P, a=A):
    if x1 is None or y1 is None:
        return x2, y2
    if x2 is None or y2 is None:
        return x1, y1
    if x1 == x2 and (y1 == -y2 % p or y1 == y2 and y1 == 0):
        return None, None
    if x1 == x2 and y1 == y2:
        lam = (3 * x1**2 + a) * mod_inverse(2 * y1, p) % p
    else:
        lam = (y2 - y1) * mod_inverse(x2 - x1, p) % p
    x3 = (lam**2 - x1 - x2) % p
    y3 = (lam * (x1 - x3) - y1) % p
    return x3, y3

def scalar_multiplication(k, x, y, p=P, a=A):
    if k == 0 or x is None or y is None:
        return None, None
    result_x, result_y = None, None
    addend_x, addend_y = x, y
    while k > 0:
        if k & 1:
            if result_x is None:
                result_x, result_y = addend_x, addend_y
            else:
                result_x, result_y = point_addition(result_x, result_y, addend_x, addend_y, p, a)
        addend_x, addend_y = point_addition(addend_x, addend_y, addend_x, addend_y, p, a)
        k >>= 1
    return result_x, result_y

def setup_elliptic_curve(public_key_hex):
    if public_key_hex.startswith('02') or public_key_hex.startswith('03'):
        x_hex = public_key_hex[2:]
        x = int(x_hex, 16)
        y_squared = (pow(x, 3, P) + A * x + B) % P
        y = pow(y_squared, (P + 1) // 4, P)
        if (public_key_hex.startswith('02') and y % 2 != 0) or (public_key_hex.startswith('03') and y % 2 == 0):
            y = P - y
    else:
        x_hex = public_key_hex[2:66]
        y_hex = public_key_hex[66:130]
        x = int(x_hex, 16)
        y = int(y_hex, 16)
    return (x, y), P, A, B

def create_superposition(circuit, qr):
    for qubit in qr:
        circuit.h(qubit)

def modular_exponentiation_operator(circuit, control, target, public_key_x, public_key_y, n_count):
    for i in range(n_count):
        power = 2**i
        point_x, point_y = scalar_multiplication(power, G_X, G_Y)
        for j in range(min(4, len(target))):
            circuit.cp(np.pi / (2**(j+1)), control[i], target[j])

def apply_qpe(circuit, control_register, target_register, public_key_x, public_key_y):
    n_count = len(control_register)
    circuit.x(target_register[0])
    modular_exponentiation_operator(circuit, control_register, target_register, public_key_x, public_key_y, n_count)
    circuit.append(QFT(n_count, do_swaps=True).inverse(), control_register)

def error_correction_repetition_code(circuit, data_qubits, ancilla_qubits):
    for i in range(min(len(data_qubits) - 1, len(ancilla_qubits))):
        circuit.cx(data_qubits[i], ancilla_qubits[i])
        circuit.cx(data_qubits[i + 1], ancilla_qubits[i])
        circuit.barrier()
    for i in range(len(ancilla_qubits)):
        circuit.measure(ancilla_qubits[i], i)

def quantum_key_recovery(num_qubits, public_key_hex):
    public_key_point, _, _, _ = setup_elliptic_curve(public_key_hex)
    public_key_x, public_key_y = public_key_point
    qr = QuantumRegister(num_qubits, 'q')       # 16 data qubits
    aux = QuantumRegister(4, 'aux')             # 4 auxiliary for QPE
    ancilla = QuantumRegister(4, 'ancilla')     # 4 ancilla for repetition code
    cr = ClassicalRegister(num_qubits + 4, 'c') # 20 classical bits (16 data + 4 ancilla)
    circuit = QuantumCircuit(qr, aux, ancilla, cr)
    
    create_superposition(circuit, qr)
    circuit.barrier()
    apply_qpe(circuit, qr, aux, public_key_x, public_key_y)
    circuit.barrier()
    error_correction_repetition_code(circuit, qr, ancilla)
    circuit.barrier()
    circuit.measure(qr, cr[:num_qubits])
    return circuit

def find_period_from_measurement(counts, num_qubits):
    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)
    most_frequent = sorted_counts[0][0]
    measured_phase = int(most_frequent[:num_qubits], 2)  # Only data qubits
    phase = measured_phase / (2**num_qubits)
    frac = Fraction(phase).limit_denominator(SECP256K1_ORDER)
    period = frac.denominator
    if 1 <= period <= 2**num_qubits - 1:
        return period
    return None

def majority_vote(results, num_qubits):
    periods = [find_period_from_measurement(counts, num_qubits) for counts in results if counts]
    valid_periods = [p for p in periods if p is not None]
    if not valid_periods:
        return None
    return Counter(valid_periods).most_common(1)[0][0]

def verify_private_key(private_key, public_key_hex):
    public_key_point, _, _, _ = setup_elliptic_curve(public_key_hex)
    point_x, point_y = scalar_multiplication(private_key, G_X, G_Y)
    if point_y is None:
        return False
    computed_public_key = "03" + format(point_x, '064x') if point_y % 2 else "02" + format(point_x, '064x')
    return computed_public_key == public_key_hex

def run_quantum_search(public_key_hex, num_qubits=16, num_shots=8192, max_attempts=5):
    logger.info(f"Using backend: {backend.name}")
    results = []

    for attempt in range(1, max_attempts + 1):
        try:
            qc = quantum_key_recovery(num_qubits, public_key_hex)
            transpiled_qc = transpile(qc, backend=backend, optimization_level=3)
            sampler = Sampler(backend)
            job = sampler.run([transpiled_qc], shots=2048)
            # job = service.job('d116x2wn2txg008jj9yg')
            job_result = job.result()
            job_id = job.job_id()
            print(f"Job submitted. Job ID: {job_id}")
            logger.info(f"Attempt {attempt}: Job submitted. Job ID: {job_id}")
            logger.info("Waiting for job results...")
            print("Waiting for results...")
            pub_result = job_result[0].data.c.get_counts()
            result = job.result()
            counts = result[0].data.c.get_counts()
            print("Measurement Results:")
            print(pub_result)

            # Output results
            print(f"Dominant measurement: {max(counts, key=counts.get)} with {counts[max(counts, key=counts.get)]} counts")
            logger.info(f"Attempt {attempt}: Job completed with {len(counts)} measurements")

            # Convert quasi-probabilities to integer counts
            counts_int = {bin(int(k))[2:].zfill(num_qubits): int(v * num_shots) for k, v in counts.items()}
            results.append(counts_int)
        except Exception as e:
            logger.error(f"Attempt {attempt}: Error: {e}. Retrying.")

    period = majority_vote(results, num_qubits)
    if period:
        padded_key = hex(period)[2:].zfill(64)
        if verify_private_key(period, public_key_hex):
            logger.info(f"Found private key after {max_attempts} attempts: {padded_key}")
            return period
        else:
            logger.info(f"Incorrect key after voting: {padded_key}")
    else:
        logger.info("No valid period found across attempts.")
    return None

import numpy as np
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, transpile
from qiskit.circuit.library import QFT
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt

# 1. Elliptic Curve Setup (Toy Example, Replace with 134-bit Parameters)
def setup_elliptic_curve():
    p = 2**134 - 159  # 134-bit prime (example)
    a = 2
    b = 3
    G = (1, 2)  # Replace with actual generator
    return p, a, b, G

# 2. Modular Inverse
def mod_inverse(a, p):
    return pow(a, -1, p)

# 3. Point Operations
def point_addition(P, Q, a, p):
    if P == Q:
        return point_doubling(P, a, p)
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2:
        return (None, None)
    m = ((y2 - y1) * mod_inverse(x2 - x1, p)) % p
    x3 = (m**2 - x1 - x2) % p
    y3 = (m * (x1 - x3) - y1) % p
    return (x3, y3)

def point_doubling(P, a, p):
    x1, y1 = P
    m = ((3 * x1**2 + a) * mod_inverse(2 * y1, p)) % p
    x3 = (m**2 - 2 * x1) % p
    y3 = (m * (x1 - x3) - y1) % p
    return (x3, y3)

# 4. Classical Scalar Multiplication (Setup only)
def scalar_multiplication(k, P, a, p):
    R = None
    for bit in bin(k)[2:]:
        if R is None:
            R = P
        else:
            R = point_doubling(R, a, p)
        if bit == '1':
            R = point_addition(R, P, a, p)
    return R

# 5. Placeholder Eigenstate Preparation
def eigenstate_prep(qc, idx):
    qc.x(idx)  # Set last qubit to |1⟩ as dummy eigenstate

# 6. Quantum Phase Estimation Circuit
def apply_qpe(num_bits, unitary, eigenstate_prep):
    qc = QuantumCircuit(num_bits + 1, num_bits)

    # Apply Hadamards to phase register
    qc.h(range(num_bits))

    # Prepare the eigenstate
    eigenstate_prep(qc, num_bits)

    # Apply dummy controlled-U operations
    for j in range(num_bits):
        qc.cu1(2 * np.pi / 2**(j+1), j, num_bits)  # Placeholder for actual EC group operation

    # Apply inverse QFT
    qc.append(QFT(num_qubits=num_bits, inverse=True), range(num_bits))

    # Measure
    qc.measure(range(num_bits), range(num_bits))
    return qc

# 7. Run on IBM Quantum Real Hardware
def run_on_ibm_quantum(qc, backend_name="ibm_brisbane", shots=1024):
    # Authenticate with your IBM Quantum account (set once and saved)
    QiskitRuntimeService.save_account(
        channel='ibm_quantum',
        token='YOUR_IBM_QUANTUM_TOKEN_HERE',  # <- REPLACE THIS
        instance='ibm-q/open/main',
        overwrite=True,
        set_as_default=True
    )

    service = QiskitRuntimeService()
    backend = service.backend(backend_name)

    print(f"Using backend: {backend.name}")
    
    transpiled_qc = transpile(qc, backend=backend, optimization_level=3)
    sampler = Sampler(backend=backend)

    job = sampler.run([transpiled_qc], shots=shots)
    print(f"Job submitted: {job.job_id()}")
    result = job.result()

    # Plot and return result
    counts = result[0].data.c.get_counts()
    plot_histogram(counts)
    return counts

# 8. Main function to orchestrate everything
def main():
    p, a, b, G = setup_elliptic_curve()
    num_bits = 5  # Small test size for demonstration; real case: 134

    unitary = None  # Placeholder for EC unitary operator
    qc = apply_qpe(num_bits, unitary, eigenstate_prep)

    print(qc)  # Optional: print circuit
    counts = run_on_ibm_quantum(qc, backend_name="ibm_brisbane", shots=1024)

    print("Measurement counts:")
    for outcome, count in counts.items():
        print(f"{outcome}: {count}")

if __name__ == "__main__":
    main()

def quantum_brute_force(public_key_x: int, g_x: int, g_y: int, p: int, min_range: int, max_range: int) -> int:
    """Main function to perform quantum brute-force search for private keys."""
    if max_range <= min_range:
        raise ValueError("max_range must be greater than min_range.")
# private_key = quantum_brute_force(public_key_hash, g_x, g_y, p, min_range, max_range, iterations)

    #Initialize IBMQ account and provider
    #IBMQ.load_account()
    #provider = IBMQ.get_provider(hub='ibm-q')
    #backend = provider.get_backend('ibm_nairobi')

# -----------------------------------------------------------------------------------------------------
# Elliptic Curve Parameters (Secp256k1)
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
     0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8)

def verify_private_key(private_key, G_X, G_Y, pub_key_x, pub_key_y, p):
    point_x, point_y = scalar_multiplication(private_key, G_X, G_Y, p)  # <-- FIXED
    return point_x == pub_key_x and point_y == pub_key_y

# Public Key
public_key_hex = "033f688bae8321b8e02b7e6c0a55c2515fb25ab97d85fda842449f7bfa04e128c3"
x_Q = int(public_key_hex[2:], 16)

def gcd(a, b):
    """Computes the greatest common divisor of a and b using Euclidean algorithm."""
    while b:
        a, b = b, a % b
    return a

def mod_exp(base, exp, mod):
    """Performs modular exponentiation: (base^exp) % mod."""
    result = 1
    base = base % mod
    while exp > 0:
        if exp % 2 == 1:  # If exp is odd
            result = (result * base) % mod
        exp = exp >> 1  # Divide exp by 2
        base = (base * base) % mod
    return result

def find_period(a, N):
    """Finds the period of a^x % N for a given base a."""
    x = a
    r = 1
    while x != 1:
        x = (x * a) % N
        r += 1
        if r > N:  # If no period found
            return None
    return r

def shor_algorithm(N):
    """Classical implementation of Shor's factoring algorithm."""
    if N % 2 == 0:
        return 2  # 2 is a factor of all even numbers
    
    # Try random values of a
    for _ in range(100):  # Try 100 different values for a
        a = random.randint(2, N-1)
        
        # Check if gcd(a, N) is non-trivial
        common_divisor = gcd(a, N)
        if common_divisor > 1:
            return common_divisor
        
        # Find the period of a^x % N
        r = find_period(a, N)
        if r and r % 2 == 0:
            # Find factors using the period
            factor1 = gcd(mod_exp(a, r//2, N) - 1, N)
            factor2 = gcd(mod_exp(a, r//2, N) + 1, N)
            if factor1 > 1 and factor1 < N:
                return factor1
            if factor2 > 1 and factor2 < N:
                return factor2
    
    return None  # If no factor is found after 100 attempts

def mod_inverse(a, p):
  if a == 0:
    return 0
  lm, hm = 1, 0
  low, high = a % p, p
  while low > 1:
    ratio = high // low
    nm, new_low = hm - lm * ratio, high - low * ratio
    lm, low, hm, high = nm, new_low, lm, low
  return lm % p

def scalar_multiplication(k, x, y, p):
    x_res, y_res = x, y
    k_bin = bin(k)[2:]
    for bit in k_bin[1:]:
        x_res, y_res = point_doubling(x_res, y_res, p)
        if bit == '1':
            x_res, y_res = point_addition(x_res, y_res, x, y, p)
    return x_res, y_res

def point_doubling(x, y, p):
    # Elliptic curve point doubling formula
    s = (3 * x**2) * pow(2 * y, -1, p) % p
    x_res = (s**2 - 2 * x) % p
    y_res = (s * (x - x_res) - y) % p
    return x_res, y_res

def point_addition(x1, y1, x2, y2, p):
    # Elliptic curve point addition formula
    if x1 == x2 and y1 == y2:
        return point_doubling(x1, y1, p)
    s = (y2 - y1) * pow(x2 - x1, -1, p) % p
    x_res = (s**2 - x1 - x2) % p
    y_res = (s * (x1 - x_res) - y1) % p
    return x_res, y_res

##private_key = solve_ecdlp(p, x_Q)
def solve_ecdlp(p, x_Q):
    """Solves ECDLP using Shor's algorithm."""
    # Step 1: Factor the modulus p using Shor's algorithm
    private_key = shor_algorithm(p)
    if private_key is None:
        print("Failed to factor modulus p.")
        return None
    return private_key

# Function to convert private key to compressed Bitcoin address
def private_key_to_compressed_address(private_key_hex):
    print(f"Converting private key {private_key_hex} to Bitcoin address...")
    private_key_bytes = bytes.fromhex(private_key_hex)
    sk = SigningKey.from_string(private_key_bytes, curve=SECP256k1)
    vk = sk.verifying_key
    public_key_bytes = vk.to_string()
    x_coord = public_key_bytes[:32]
    y_coord = public_key_bytes[32:]
    prefix = b'\x02' if int.from_bytes(y_coord, 'big') % 2 == 0 else b'\x03'
    compressed_public_key = prefix + x_coord

    sha256_pk = hashlib.sha256(compressed_public_key).digest()
    ripemd160 = RIPEMD160.new()  # Using Cryptodome's RIPEMD160
    ripemd160.update(sha256_pk)
    hashed_public_key = ripemd160.digest()

    network_byte = b'\x00' + hashed_public_key
    sha256_first = hashlib.sha256(network_byte).digest()
    sha256_second = hashlib.sha256(sha256_first).digest()
    checksum = sha256_second[:4]

    binary_address = network_byte + checksum
    bitcoin_address = base58.b58encode(binary_address).decode('utf-8')
    print(f"Generated Bitcoin address: {bitcoin_address}")
    return bitcoin_address   

def public_key_to_btc_address(x, y, compressed=True):
    """Generates a Bitcoin address from the public key."""
    if compressed:
        prefix = b'\x02' if y % 2 == 0 else b'\x03'
        public_key = prefix + x.to_bytes(32, 'big')
    else:
        public_key = b'\x04' + x.to_bytes(32, 'big') + y.to_bytes(32, 'big')
    sha256 = hashlib.sha256(public_key).digest()
    ripemd160 = hashlib.new('ripemd160', sha256).digest()
    return ripemd160

# Function to convert public key to Public-Key-Hash (SHA256 -> RIPEMD160)
def public_key_to_public_key_hash(public_key_hex):    
    try:
        # Step 1: Perform SHA-256 on the public key
        sha256_hash = SHA256.new(bytes.fromhex(public_key_hex)).digest()
        
        # Step 2: Perform RIPEMD-160 on the result of SHA-256 using Cryptodome
        ripemd160 = RIPEMD160.new()  # Using Cryptodome's RIPEMD160
        ripemd160.update(sha256_hash)
        ripemd160_hash = ripemd160.digest()
        
        # Return the Public-Key-Hash in hexadecimal format
        return ripemd160_hash.hex()
    
    except ValueError as e:
        raise ValueError(f"Invalid input for public key hex: {e}")

# Get the top 10 most frequent results
def get_top_10_frequent(counts):
    sorted_counts = sorted(counts.items(), key=lambda item: item[1], reverse=True)
    top_10_counts = sorted_counts[:10]
    print(f"Top 10 most frequent counts: {top_10_counts}")
    return [int(bitstring, 2) for bitstring, _ in top_10_counts]

# Function to convert binary to hex
def binary_to_hex(bin_key):
    bin_key = bin_key.zfill(128)  # Ensure 128-bit padding
    return hex(int(bin_key, 2))[2:].zfill(64)

# Convertir une chaîne binaire en hexadécimal
def binary_to_hex(bin_str):
    hex_str = hex(int(bin_str, 2))[2:].upper()
    return hex_str.zfill(64)  # Remplir la chaîne hex pour s'assurer qu'elle fait 64 caractères (32 octets)

def retrieve_job_result(job_id, target_address, quantum_registers):
    """Retrieve job results and check for valid private keys."""
    target_address = "1HduPEXZRdG26SUT5Yk83mLkPyjnZuJ7Bm"
    print(f"Retrieving job result for job ID: {job_id}...")
    service = QiskitRuntimeService()
    quantum_registers = 20  # Use 20 qubits for the search
    try:
        # Retrieve job result from the quantum device
        job = service.job(job_id)
        job_result = job.result()
        print(f"Job result retrieved for job ID {job_id}")
    except Exception as e:
        print(f"Error retrieving job result: {e}")
        return None, None

    try:
        # Access the measurement results (which are binary strings like '010101')
        counts = job_result[0].data.c.get_counts()
        print("Counts retrieved from job:", counts)

        # Post-process results to find the private key
        private_key_candidates = sorted(counts.keys(), key=lambda x: counts[x], reverse=True)[:10]
        print("Top candidates:", private_key_candidates)

        # Check each binary result for a valid private key
        for bin_key, count in counts.items():
            bin_key = bin_key.strip()

            # Ensure the key is exactly 20 bits
            if len(bin_key) < quantum_registers:
                bin_key = bin_key.ljust(quantum_registers, '0')
            elif len(bin_key) > quantum_registers:
                bin_key = bin_key[:quantum_registers]

            print(f"\nChecking binary key (first 20 bits): {bin_key} with length {len(bin_key)}")
            print(f"Key count: {count} times generated")

            # Convert binary string to hex
            private_key_hex = binary_to_hex(bin_key)
            if private_key_hex is None:
                continue  # Skip if conversion failed

            # Convert to compressed Bitcoin address
            compressed_address = private_key_to_compressed_address(private_key_hex)

            # Check if the private key produces the target Bitcoin address
            if compressed_address == target_address:
                print(f"Valid private key found: {private_key_hex}")

                # Save the valid private key and address to boom.txt
                with open('boom.txt', 'a') as file:
                    file.write(f"Private Key: {private_key_hex}\n")
                    file.write(f"Compressed Address: {compressed_address}\n\n")

                return private_key_hex, compressed_address

        print("No matching private key found.")
        return None, None

    except Exception as e:
        print(f"Unexpected error: {e}")
        return None, None

# Plot histogram of measurement results
def plot_result_histogram(counts):
    plot_histogram(counts)
    labels, values = zip(*counts.items())  # Unpack the counts dictionary
    if isinstance(labels[0], str) and all(set(label).issubset({'0', '1'}) for label in labels):
        hex_labels = [binary_to_hex(label) for label in labels]
    else:
        hex_labels = labels
    
    plt.bar(range(len(values)), values, tick_label=hex_labels)
    plt.xlabel('Private Keys (Hex)' if isinstance(hex_labels[0], str) else 'Private Key Candidates')
    plt.ylabel('Counts')
    plt.title('Measurement Counts Histogram')
    plt.tight_layout()
    plt.show()

def plot_results_histogram(counts):
    labels, values = zip(*counts.items())
    hex_labels = [binary_to_hex(label) for label in labels]
    plt.bar(range(len(values)), values, tick_label=hex_labels)
    plt.xlabel('Private Keys (Hex)')
    plt.ylabel('Counts')
    plt.title('Measurement Counts Histogram')
    plt.xticks(rotation=90)
    plt.show()

def shor_oracle(qc, a, N, qubits):
    """Adds Shor's algorithm as an oracle to the quantum circuit."""
    for i in range(len(qubits)):
        qc.cx(qubits[i], a)  # Controlled modular exponentiation

def quantum_circuit(num_qubits, Gx, Gy, Px, p):
    q_x = QuantumRegister(num_qubits, 'x')  # Register for the private key
    anc = QuantumRegister(1, 'ancilla')     # Ancilla qubit
    qc_aux = QuantumRegister(num_qubits, 'auxiliary')  # Auxiliary register for swaps
    c = ClassicalRegister(num_qubits + 1, 'c')  # Classical register for measurement
    qc = QuantumCircuit(q_x, anc, qc_aux, c)
    print("Quantum circuit initialized.")

    # Initialize superposition
    print("Initialized qubits in Superposition.")
    qc.h(q_x)
    qc.h(anc)
    print("Hadamard gates applied.")

    # ECDLP Oracle: Find k such that [k]G = P
    for i in range(num_qubits):
        k = 2 ** i
        Qx, Qy = scalar_multiplication(k, Gx, Gy, p)  # <-- FIXED

        # Simulate comparison with target public key Px
        if Qx == Px:
            qc.z(q_x[i])  # Apply phase flip if match (simplified oracle simulation)

        # Controlled point logic (placeholder):
        qc.cswap(anc[0], q_x[i], qc_aux[i])  # Use auxiliary qubit for swap
        qc.cx(q_x[i], anc[0])  # Controlled NOT for equality check

    # Add Shor's oracle to factor the modulus p
    shor_oracle(qc, anc, p, q_x)

    # Apply QFT for Quantum Phase Estimation
    qc.append(QFT(num_qubits, do_swaps=True), q_x)

    # Apply inverse QFT
    qc.append(QFT(num_qubits, do_swaps=True).inverse(), q_x)

    # Measurement
    qc.measure(q_x, c[:num_qubits])
    qc.measure(anc[0], c[num_qubits])

    return qc

def main():

    # Define your constants and parameters
    min_range = 0x10000
    max_range = 0x1FFFF
    num_qubits = int(np.ceil(np.log2(max_range))) + 1
    target_address = "1HduPEXZRdG26SUT5Yk83mLkPyjnZuJ7Bm"
    public_key_x_hex = "0x6ef0691fa9edd5a21e6be331d5c4aa21c18a520d"
    public_key_hash = "b67cb6edeabc0c8b927c9ea327628e7aa63e2d52"
    public_key_hex = "033f688bae8321b8e02b7e6c0a55c2515fb25ab97d85fda842449f7bfa04e128c3"
    keyspace_size = max_range - min_range + 1
    quantum_registers = 20
    num_shots = 8192

    print(f"Calculated keyspace size: {keyspace_size}")
    print(f"Number of Qubits: {num_qubits}")
    print(f"Calculated iterations: {int(np.sqrt(float(max_range - min_range)))}")

    x_Q = int(public_key_x_hex, 16)
    p = int(public_key_hex, 16)
    results = []

    print(f"\nInitializing circuit with {num_qubits} qubits...")
    qc = quantum_circuit(num_qubits, G[0], G[1], x_Q, p)

    print("Quantum Circuit Details:")
    print(qc)
    print(f"Circuit Depth: {qc.depth()}, Circuit Size: {qc.size()}")

    service = QiskitRuntimeService()
    backend = service.backend('ibm_brisbane')
    print(f"Selected backend: {backend}")

    print("Transpiling the quantum circuit...")
    transpiled_circuit = transpile(qc, backend=backend, optimization_level=3)
    print(f"Transpiled circuit depth: {transpiled_circuit.depth()}")

    print("Assembling the circuit into a Qobj...")
    print("Qobj assembled successfully.")

    print("Submitting the job to the backend...")
    sampler = Sampler(backend)
    job = sampler.run([transpiled_circuit], shots=8192)
    job_id = job.job_id()
    print(f"Job submitted. Job ID: {job_id}")
    print("Waiting for results...")

    result = job.result()
    counts = result[0].data.c.get_counts()

    print("Measurement Results:")
    print(counts)

    if not counts:
        print("No results returned from the quantum circuit!")
        return None

    print(f"Dominant measurement: {max(counts, key=counts.get)} with {counts[max(counts, key=counts.get)]} counts")

    counts_int = {
        bin(int(k))[2:].zfill(num_qubits): int(v * num_shots)
        for k, v in counts.items()
    }
    results.append(counts_int)

    period = majority_vote(results, num_qubits)
    if period:
        padded_key = hex(period)[2:].zfill(64)
        if verify_private_key(period, public_key_hex):
            print(f"Found private key: {padded_key}")
            return period
        else:
            print(f"Incorrect key after voting: {padded_key}")
    else:
        print("No valid period found.")

    print("Plotting result distributions...")
    plot_distribution(counts, legend=["IBM Sherbrooke - Quantum ECDLP Solver"])
    plot_histogram(counts)
    plt.show()

    found_key, compressed_address = retrieve_job_result(job_id, target_address, quantum_registers)

    if found_key:
        print("\nSUCCESS! Private key:")
        print(f"Found matching private key: {found_key}")
        print(f"HEX: {hex(found_key)}")
        print(f"DEC: {found_key}")
        with open("boom.txt", "w") as file:
            file.write("Measurement Results:\n")
            for bitstring, count in counts.items():
                file.write(f"{bitstring}: {count}\n")
        print("Results saved to boom.txt")
    else:
        print("No valid key found.")

    private_key = int(max(counts, key=counts.get), 2)
    print(f"Private Key Found: {private_key}")

    computed_x, _ = scalar_multiplication(private_key, G[0], G[1], p)
    if computed_x == x_Q:
        print("Private Key Verified Successfully!")
        with open("boom.txt", "w") as file:
            file.write(f"Private Key: {private_key}\n")
            file.write(f"HEX: {hex(private_key)}\n")
            file.write(f"DEC: {private_key}\n")
        print("Private key saved to boom.txt")
    else:
        print("Private Key Verification Failed.")

    return None

if __name__ == "__main__":
    main()
 