import numpy as np
from math import ceil, log2, sqrt
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer, transpile, execute
from qiskit.circuit.library import QFT
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt

# --- Toy elliptic curve parameters ---
# Curve: y^2 = x^3 + a*x + b over finite field F_p
p = 17
a = 2
b = 2

# Base point G on the curve
G = (5, 1)

# Secret scalar (unknown to quantum algorithm)
secret_scalar = 7

# --- Modular inverse ---
def modinv(k, p):
    """Modular inverse of k mod p using Extended Euclidean Algorithm."""
    if k == 0:
        raise ZeroDivisionError('division by zero')
    s, old_s = 0, 1
    t, old_t = 1, 0
    r, old_r = p, k
    while r != 0:
        quotient = old_r // r
        old_r, r = r, old_r - quotient * r
        old_s, s = s, old_s - quotient * s
        old_t, t = t, old_t - quotient * t
    if old_r != 1:
        raise ValueError(f"{k} has no inverse mod {p}")
    return old_s % p

# --- Elliptic curve point operations ---
def is_inf(P):
    return P is None

def point_add(P, Q):
    if is_inf(P):
        return Q
    if is_inf(Q):
        return P
    x1, y1 = P
    x2, y2 = Q
    if x1 == x2 and (y1 != y2 or y1 == 0):
        return None  # Point at infinity
    if P == Q:
        s = (3 * x1 * x1 + a) * modinv(2 * y1, p) % p
    else:
        s = (y2 - y1) * modinv(x2 - x1, p) % p
    x3 = (s * s - x1 - x2) % p
    y3 = (s * (x1 - x3) - y1) % p
    return (x3, y3)

def scalar_mult(k, P):
    result = None
    addend = P
    while k > 0:
        if k & 1:
            result = point_add(result, addend)
        addend = point_add(addend, addend)
        k >>= 1
    return result

# --- Quantum oracle ---
def oracle_phase_function(x, G, Q, p):
    """
    Phase function f(x) = 0 if x*G != Q, 0.5 if x*G == Q (flip phase).
    """
    Px = scalar_mult(x, G)
    if Px == Q:
        return 0.5  # phase flip by pi
    else:
        return 0.0

# --- Quantum Simulator with phase oracle ---
class QuantumSimulator:
    def __init__(self, n_qubits):
        self.n_qubits = n_qubits
        self.n_states = 2 ** n_qubits
        self.state = np.ones(self.n_states, dtype=complex) / sqrt(self.n_states)

    def apply_phase_oracle(self, f):
        new_state = np.zeros_like(self.state)
        for i in range(self.n_states):
            phase = f(i)
            new_state[i] = self.state[i] * np.exp(2j * np.pi * phase)
        self.state = new_state

    def apply_qft(self):
        dft = np.fft.fft(np.eye(self.n_states)) / sqrt(self.n_states)
        self.state = dft @ self.state

    def measure(self, shots=1000):
        probs = np.abs(self.state) ** 2
        return np.random.choice(self.n_states, size=shots, p=probs)

# --- Main quantum discrete log algorithm ---
def quantum_discrete_log(G, Q, p, n_qubits):
    print(f"Running quantum discrete log on toy curve with {n_qubits} qubits")

    qsim = QuantumSimulator(n_qubits)

    # Apply phase oracle encoding discrete log problem
    qsim.apply_phase_oracle(lambda x: oracle_phase_function(x, G, Q, p))

    # Apply QFT to extract phase
    qsim.apply_qft()

    # Measure
    shots = 2000
    results = qsim.measure(shots=shots)

    # Count results
    unique, counts = np.unique(results, return_counts=True)
    sorted_indices = np.argsort(counts)[::-1]
    best = unique[sorted_indices[0]]

    # Estimate phase and recover discrete log
    phase_estimate = best / (2 ** n_qubits)
    keyspace_size = 2 ** n_qubits
    estimated_key = int(round(phase_estimate * keyspace_size)) % keyspace_size

    print(f"Most frequent measurement: {best} (decimal)")
    print(f"Estimated phase: {phase_estimate}")
    print(f"Estimated discrete log (mod {keyspace_size}): {estimated_key}")

    return estimated_key

# --- Extended Euclidean Algorithm for modular inverse ---
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    g, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return g, x, y

# --- Run example ---
def main():
    # Secret scalar and public key
    secret = secret_scalar
    Q = scalar_mult(secret, G)
    print(f"Secret scalar: {secret}")
    print(f"Public key Q: {Q}")

    # Number of qubits (choose enough to cover keyspace)
    n_qubits = 4  # 4 qubits -> keyspace size 16

    # Run quantum discrete log simulation
    estimated_key = quantum_discrete_log(G, Q, p, n_qubits)

    # Verify result
    if scalar_mult(estimated_key, G) == Q:
        print("✓ SUCCESS: Private key recovered!")
    else:
        print("✗ FAILURE: Incorrect key recovered.")

if __name__ == "__main__":
    main()
